% !Mode:: "TeX:UTF-8"
\documentclass{../common/tufte-latex/tufte-handout}

\title{Git hands-on, part I: single user operations}

\author{S\'ebastien Dawans}

\date{21 January 2014} % without \date command, current date is supplied

%\geometry{showframe} % display margins for debugging page layout
\usepackage[utf8]{inputenc}
\usepackage{graphicx} % allow embedded images
  \setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
  \graphicspath{{graphics/}} % set of paths to search for images
\usepackage{amsmath}  % extended mathematics
\usepackage{booktabs} % book-quality tables
\usepackage{units}    % non-stacked fractions and better unit spacing
\usepackage{multicol} % multiple column layout facilities
\usepackage{lipsum}   % filler text
\usepackage{fancyvrb} % extended verbatim environments
  \fvset{fontsize=\normalsize}% default font size for fancy-verbatim environments
\usepackage{listings}
\lstset{showstringspaces=false}
\usepackage[usenames]{xcolor}

\lstdefinestyle{BashInputStyle}{
  language=bash,
  basicstyle=\footnotesize\ttfamily,
  %numbers=left,
  %numberstyle=\tiny,
  %numbersep=3pt,
  frame=tb,
  columns=fullflexible,
  backgroundcolor=\color{yellow!20},
  linewidth=0.95\linewidth,
  xleftmargin=0.05\linewidth,
  moredelim=**[is][\color{red}]{§}{§},
  moredelim=**[is][\color{OliveGreen}]{`}{`}
}

% Standardize command font styles and environments
\newcommand{\doccmd}[1]{\texttt{\textbackslash#1}}% command name -- adds backslash automatically
\newcommand{\docopt}[1]{\ensuremath{\langle}\textrm{\textit{#1}}\ensuremath{\rangle}}% optional command argument
\newcommand{\docarg}[1]{\textrm{\textit{#1}}}% (required) command argument
\newcommand{\docenv}[1]{\textsf{#1}}% environment name
\newcommand{\docpkg}[1]{\texttt{#1}}% package name
\newcommand{\doccls}[1]{\texttt{#1}}% document class name
\newcommand{\docclsopt}[1]{\texttt{#1}}% document class option name
\newenvironment{docspec}{\begin{quote}\noindent}{\end{quote}}% command specification environment

\begin{document}

\maketitle% this prints the handout title, author, and date

\begin{abstract}
\noindent
This handout is a walkthrough for a 4-hour hands-on session on Git.
The goal is to offer a first experience with Git on the client side using Git's native command-line interface to learn basic concepts about Source Code Management with Git.
The intended audience for this session is one or more developers having already received in introduction to basic Git concepts, such as those available in the presentations folder of the git-slides repository \url{https://github.com/sdawans/git-slides}.
This session deals exclusively with single-user repositories, ideal for training multiple people at the same time without having to deal with multi-developer workflows at the very beginning.
\end{abstract}

%\printclassoptions

\section{Introduction}\label{sec:intro}

Git is a Source Code Management (SCM) system with three key design principles.
Git is \textbf{Distributed}, \textbf{Fast} and \textbf{Reliable}.
It is very different from not only centralized SCMs like SVN, but also other forms of distributed SCMs like Mercurial.
To follow this introductory session, it's best to clear your mind of everything you know about other SCMs, as some false similarities are often misleading.

\section{Preparation}

In preparation of this course, each participant must have a properly installed and configured command-line client for Git, and access to the git repositories hosted on a local instance of Gitlab.

\subsection{Installing a Git client}\label{sec:preparation}

Linux and MacOS X users will find the native git client in their respective package managers.
Windows users should install the latest versions of TortoiseGit \marginnote{\url{http://code.google.com/p/tortoisegit/}} (for the TortoisePlink.exe binary) and msysgit \marginnote{\url{http://code.google.com/p/msysgit/}}, in that order.
In the msysgit installation wizard, the path to TortoisePlink.exe should be selected when prompted for the SSH connexion handler.
Furthermore, windows users will need puttygen.exe and pageant.exe, available on the Putty website \marginnote{\url{http://www.putty.org/}}.

An SSH keypair must be generated with puttygen.
The contents of the public key should be copy/pasted in your Gitlab user settings while the private key should be stored locally and added to pageant. \marginnote{When pasting the public key in Gitlab, make sure you copy it directly from the puttygen application, and not from the public key file saved on disk. This avoids problems caused by superfluous endlines.}
You may want to write a batch script to automatically run pageant at system boot and load the private key.

\subsection{Configuring Git}

People are an important aspect in any SCM, as every code change must be attributed to a certain author.
\marginnote{In fact, Git manages users thoroughly by seperating \textbf{authors} from \textbf{committers}.
An author is the person who (originally) writes a certain patch (new code, code modification), while the committer is the person who applies the said changes on a particular code base.}
The user must thus identify himself before using a git client.
Git uses a global \texttt{user.name} and \texttt{user.email} setting applied to all projects, which is overridable locally for a specific project.
For this session, we will set the global settings for all the projects on the machine:

\begin{lstlisting}[style=BashInputStyle]
  $ git config --global user.name "First Last"
  $ git config --global user.email "first.last@example.com"
\end{lstlisting}

Another useful configuration (already default on msysgit) is to enable color output in the console.

\noindent To do so:

\begin{lstlisting}[style=BashInputStyle]
  $ git config --global color.ui true
\end{lstlisting}

Windows users who are not comfortable with Vim, the default commit-message editor in msysgit, can define a \texttt{core.editor} option to another editor.
For example, to use Notepad++ as default:

\marginnote{According to \url{http://starikovs.com/2012/11/06/git-core-editor-windows/}, you can simple write 'notepad++' instead of the full path to the application if it is correctly defined in your PATH environment variable.}
\begin{lstlisting}[style=BashInputStyle]
  $ git config --global core.editor
    "'C:/path/to/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"
\end{lstlisting}

\noindent For a full list of global and locally overridden parameters, use

\begin{lstlisting}[style=BashInputStyle]
  $ git config --list
\end{lstlisting}

A final useful configuration before getting started is \textbf{shell prompt customization}.
Windows users using msysgit already have a very basic form of preconfigured customization. \marginnote{Git Prompt: \url{http://volnitsky.com/project/git-prompt/}}
For Unix-based systems, I recommend the highly configurable git-prompt project. 

%TODO: make my notes on git-prompt public and add a link to it

\subsection{Accessing GitLab}

\marginnote{My feedback on GitLab [FR] \url{https://www.cetic.be/Solution-Open-Source-et-complete-d}}
\begin{marginfigure}%
  \centering
  \includegraphics[width=0.6\linewidth]{gitlab-logo.png}
  \label{fig:gitlablogo}
\end{marginfigure}
For these sessions, our shared Git repositories will be hosted on a local instance of GitLab, a popular open-source Git hosting solution.

Gitlab offers a web interface to manage and visualize the git repositories hosted on the Git server.
Each git repository hosted on Gitlab can be visualized via a unique URL, usually \\ \noindent \texttt{http://gitlab.server.com/namespace/project}.
The \textbf{namespace} can be of two types: user-owned namespaces, which are the user logins, or group namespaces.

This tutorial is hosted in a group namespace called \textbf{Git Training}.
In order for each participant to work on his own repository in a single-user mode, we will first \textbf{fork} the lesson1 repo into each of our private namespace.

\subsection{Testing the SSH connection to the Git repositories}

The last configuration step consists in checking  that the network connexion to the Git server is functional.
\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitclone-schema.pdf}
  \label{fig:gitclone}
\end{marginfigure}
\marginnote{An optional folder name can be supplied as last argument to rename the top-level directory of the git repository.}
\marginnote{The SSH protocol is implied when using the user@server URL formatting. It is equivalent to ssh://user@server}
We can try to \textbf{clone} an existing Git repository for that.
In the Git jargon, \texttt{clone} consists in copying the entire Git repository from the remote server to the local machine.
As opposed to some centralized SCM tools like SVN, \texttt{git clone} by default will copy every single piece of information necessary to restore all previous versions ever known.
This is why we say Git is distributed: repositories are completely replicated on every machine.

\begin{lstlisting}[style=BashInputStyle]
  $ git clone git@gitlab.server.com:login/lesson1 [folder]
\end{lstlisting}

\noindent When the connection is successful, git will clone the repository and give a quite verbose output on what is going on:

\begin{lstlisting}[style=BashInputStyle]
  Cloning into 'lesson1'...
  remote: Counting objects: 23, done.
  remote: Compressing objects: 100% (17/17), done.
  remote: Total 23 (delta 3), reused 0 (delta 0)
  Receiving objects: 100% (23/23), done.
  Resolving deltas: 100% (3/3), done.
\end{lstlisting}

A new folder \texttt{lesson1} should appear in the current directory.
The Git repository (\texttt{.git folder}) and working tree are both contained inside the \texttt{lesson1} directory.
\marginnote{\texttt{lesson1}, like all Git repositories, is self-contained and can be moved around the filesystem without risk.}

\marginnote{The \texttt{.git} folder is the actual repository with all Git objects and settings. We will not go into more details about this in this course, and will ignore it hereafter}
\begin{lstlisting}[style=BashInputStyle]
  $ cd lesson1/
  $ tree -L 2 -a 
  .
  |-- .git
  |   |-- branches
  |   |-- config
  |   |-- description
  |   |-- HEAD
  |   |-- hooks
  |   |-- index
  |   |-- info
  |   |-- logs
  |   |-- objects
  |   |-- packed-refs
  |   `-- refs
  |-- python
  |   `-- calc.py
  `-- README.md
\end{lstlisting}

The \textbf{working tree} is the set of files and folders contained inside the \texttt{lesson1} folder, not including the \texttt{.git}.
\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{tree.pdf}
  \label{fig:tree}
  \caption{Representation of an arbitrary working tree for a certain commit. The files checkout out on disk and their folders are represented by blob and tree objects.}
\end{marginfigure}
In our working tree, we have a file called \texttt{README.md} in the root directory, and a \texttt{python} directory containing a single python script.
Only a single \textit{version} of the working tree can be \textit{checked out}, or "on disk" at a given time.

As we have seen in the introductory slides, the working tree is a snapshot of the whole project at a certain point of the history.
A version is uniquely identified by a \textbf{commit} object, containing author/date information and pointing to a top-level \textbf{tree} object and one or more \textbf{parent commits}.
In turn, each \textbf{tree} object contains other \textbf{tree} objects and \textbf{blob} objects, or files.
This course does not cover internal of Git, but you can find more information on Git Objects in the introductory presentation.

\section{Exploring the Repository}

So we have just cloned out first repository, and have seen the difference between the \textbf{working tree} and \textbf{local repository}.
Most of the git commands we use will interact with the local git repository to write and read information to and from the working tree.
Before we actually change anything, let's take a look at the commands available to browse the current status of a project and its history.

\subsection{Listing Remotes}

The \texttt{git clone} command initiated a local repository replicating a \textbf{remote} repository, identified by a URL.
Information related to the state of \textbf{remote} repostories is stored in a dedicated area within the Git repository.
For a name-only list of remotes, we use:

\begin{lstlisting}[style=BashInputStyle]
  $ git remote
  origin
\end{lstlisting}

Every remote is identified by a short-hand name: \textbf{origin} in this case which is the default name Git assigns to a remote when it is cloned.
We can rename a remote repository to give it a more expressive name.
Let's rename it to \texttt{gitlab}, to remind us that the remote is hosted on our local Gitlab server.

\begin{lstlisting}[style=BashInputStyle]
  $ git remote rename origin gitlab
\end{lstlisting}


There is a verbose version of \texttt{git remote} which lists the URLs to each remote.
\marginnote{There are actually 2 URLs defined for each remote, allowing to decouple \texttt{fetch} from \texttt{push} to use different protocols or even different paths for some very specific configurations.}

\begin{lstlisting}[style=BashInputStyle]
  $ git remote -v
  gitlab	git@gitlab.server.com:login/lesson1 (fetch)
  gitlab	git@gitlab.server.com:login/lesson1 (push)
\end{lstlisting}

We will get back to remotes later, let's just mention that it is possible to add and delete a remote, as well as set a new URL for an existing remote.
For example, we can set an altenate but equivalent notation of the URL:

\marginnote{This is a 1-line command displayed in 2 lines for readability. I use the "\textbackslash" character and an indented second line to represent this.}

\begin{lstlisting}[style=BashInputStyle]
  $ git remote set-url gitlab \
     ssh://git@gitlab.server.com:login/lesson1.git
\end{lstlisting}

\subsection{Local and Remote branches}

As we will see throughout this course, \textbf{branches} are omnipresent in Git.
Therefore, commands which list branches and show their relationships are particularly useful.
The simplest way to list branches is:

\marginnote{Omitting the \texttt{-a} option of \texttt{git branch} will display only the local branches.}

\begin{lstlisting}[style=BashInputStyle]
  $ git branch -a
  * `master`
  §remotes/origin/HEAD -> origin/master§
  §remotes/origin/master§
\end{lstlisting}

The output lists local and remote branches.
The local branches are first displayed in default color, with the exeption of the \textbf{currently checked-out} branch, which is displayed in green and has an asterisk next to it.
Here, the current branch is master.

The remote branches are displayed in red and are prefixed with \texttt{remotes/alias/} for readability.
There's a special \texttt{HEAD} pointing on a remote branch which simply identifies the remote branch set as the project's default branch, which will be checked out locally when doing a \texttt{git clone}.

\subsection{Viewing the history}

To view the history of the current branch:

\begin{lstlisting}[style=BashInputStyle]
  $ git log
\end{lstlisting}

This will display a verbose output of the log in a scrollable text viewer.
\marginnote{The log manpage \texttt{git log --help} is a great reference as well as online resources such as \url{http://gitready.com/advanced/2009/01/20/bend-logs-to-your-will.html}
\\ \vspace{0.5cm}
\noindent The last command shows a textual graph of the history. A useful and complete git log graph is given at \url{http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs}}
Git log has plenty of useful options, I will list a few of them here and let you experiment with them.

\begin{lstlisting}[style=BashInputStyle]
  $ git log -n 3
  $ git log --pretty=oneline
  $ git log --pretty=[short, medium, full, fuller, raw...]
  $ git log --pretty=format:'%h - %d %s (%cr) <%an>'
  $ git log --pretty=format:'%h -%C(red)%d%C(reset) %s (%cr) <%an>'
  $ git log --oneline
  $ git log --since "3 hours ago"
  $ git log --since "1 week ago"
  $ git log --graph --pretty=format:' ... '
\end{lstlisting}

\subsection{Graphical overview of branches}

We have seen that there are command-line ways of comparing commits in branches with textual graphs, but this can get complicated when dealing with multiple branches and remotes.
An alternative is to use a graphical user interface, such as Gitk which is distributed in msysgit and included in Linux and MacOS X installations.
To open Gitk:

\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitk-start.png}
  \label{fig:gitk-start}
  \caption{Our very simple project displayed in Gitk. There is only 1 local branch with a linear history.}
\end{marginfigure}

\begin{lstlisting}[style=BashInputStyle]
  $ gitk --all
\end{lstlisting}

This is by far the fastest and easiest way to get an overview of the local and remote branches.
In Gitk, the local branches are green, the current local branch is green and bold, and remote branches are prefixed with a peach path.
Our project also has a yellow label, which is a tag.
Like a branch, a \texttt{tag} is little more than a label on a certain commit, the main difference being that a tag is designed to be permanent to label an important point in the project history for future reference (code release, development milestone...), whereas a branch is meant to evolve.
We'll get back to branches and tags later.

\subsection{Working tree status}

We are about to start applying changes to our project.
A useful command to track the status of the different files in Git is \texttt{git status}:

\begin{lstlisting}[style=BashInputStyle]
  $ git status
\end{lstlisting}

As we have not yet modified anything, our git status output is very short:

\begin{lstlisting}[style=BashInputStyle]
  On branch master
  nothing to commit (working directory clean)
\end{lstlisting}

Git status is more verbose when you start changing things.
It will group files in categories according to their state: \textbf{staged}, \textbf{modified} and \textbf{untracked}.

\section{Applying our first changes to master}
In many workflows, it is usually not recommended to work directly on the master branch.
We will do so only this first time to keep things simple.
In the future, we will always apply modifications in isolated branches, and bring these changes back onto master if desireable.

\subsection{Git add to stage an untracked file}

Let's create a new file and see the output of git status:

\begin{lstlisting}[style=BashInputStyle]
  $ echo hello > newfile.txt
  $ git status
  # On branch master
  # Untracked files:
  #   (use "git add <file>..." to include in what will be committed)
  #
    §newfile.txt§
  nothing added to commit but untracked files present (use "git add" to track)
\end{lstlisting}

Git status is more verbose, it tells us that there's untracked content inside the working tree.
All files added to a git working tree are untracked, and will stay untracked unless explicitly defined as tracked content in the repository.

\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitadd-schema.pdf}
  \label{fig:gitadd}
  \caption{Git add on a file will stage all modifications in the file. It also adds untracked files to the staging area.}
\end{marginfigure}

\begin{lstlisting}[style=BashInputStyle]
  $ git add newfile.txt
  $ git status
    On branch master
    Changes to be committed:
      (use "git reset HEAD <file>..." to unstage)
  
	  `new file:   newfile.txt`
\end{lstlisting}

\subsection{Our first commit}

The staging area is unique to Git, and makes it very powerful.
\marginnote{The term commit is also used in SVN, but it is very different here. An SVN commit is non-reversible and applies changes on the remote repository. A Git commit is a local operation and can easily be undone and edited before it reaches a remote server.}
Successive modifications can be applied until the developer is satisfied with the changes, and is ready to commit them.
Committing changes will define a new point in the project history with a description, and move the HEAD and current branch to the new commit.

\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitcommit-schema.pdf}
  \label{fig:gitcommit}
  \caption{Git commit creates a new point in history, applying the changes in the staging area.}
\end{marginfigure}

\begin{lstlisting}[style=BashInputStyle]
  $ git commit -m "Added new file"
  [master 494822d] Added new file
   1 file changed, 1 insertion(+)
   create mode 100644 newfile.txt
\end{lstlisting}

Above, the commit message is given inline with the \texttt{-m} option, but it may be entered via the default text editor by omitting this option.

\subsection{Git add to stage modifications in tracked files}

Let's add more content to our new file and commit these changes.

\begin{lstlisting}[style=BashInputStyle]
  $ echo "hello again" >> newfile.txt
  $ git status
    On branch master
    Your branch is ahead of 'origin/master' by 1 commit.
  
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git checkout -- <file>..." to discard changes in working directory)
   
    §modified:   newfile.txt§
   
no changes added to commit (use "git add" and/or "git commit -a")
\end{lstlisting}

Typing \texttt{git commit} at this point will not apply anything, because the modifications have not been added to the staging area.
It is possible to apply changes on a file basis in the same way as we have staged an untracked file previously:

\begin{lstlisting}[style=BashInputStyle]
  $ git add newfile.txt
  $ git status
    On branch master
    Your branch is ahead of 'origin/master' by 1 commit.
  
    Changes to be committed:
      (use "git reset HEAD <file>..." to unstage)
  
    `modified:   newfile.txt`
 
\end{lstlisting}

Committing now will apply the modifications.

\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitk-2commits.png}
  \label{fig:gitk2commits}
  \caption{Gitk after 2 commits on the local master branch}
\end{marginfigure}

\begin{lstlisting}[style=BashInputStyle]
  $ git commit -m "Added a hello message to new file"
  [master 25d79d3] Added a hello message to new file
   1 file changed, 1 insertion(+)
\end{lstlisting}

\subsection{Git add -p: content-based staging}

Probably the cleanest way to stage changes in Git is to use the \texttt{-p} option of \texttt{git add}:

\begin{lstlisting}[style=BashInputStyle]
  $ git add -p
\end{lstlisting}

This doesn't require any files as argument.
\texttt{git add -p} will initiate an interactive session during which each modification will be displayed, and the user must decide whether to add the changes to the staging area, or leave it as modified. \marginnote{\texttt{git add -p} common commands: \textbf{y}: stage, \textbf{n}: do not stage, \textbf{d}: don't stage and skip rest of file, \textbf{s}: split into smaller chunks and ask again.}
The great thing about this command is that the modifications are presented per line (or groups of adjacent lines) rather than by file, meaning that you can stage a part of a file without staging the rest of it.
That way, it's very easy to isolate features in different commits, even if these involve modification in the same set of files.
The interactive prompt will end when all changes have been cycled through.

Suppose I have made two modifications in \texttt{calc.py} and that I have selected \textbf{y} for only one of these when running \texttt{git add -p}.
The file with contain both staged and modified lines:

\begin{lstlisting}[style=BashInputStyle]
  $ git status
    On branch master
    Your branch is ahead of 'origin/master' by 2 commits.
  
    Changes to be committed:
      (use "git reset HEAD <file>..." to unstage)
  
    `modified:   python/calc.py`
  
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git checkout -- <file>..." to discard changes in worki...
  
    §modified:   python/calc.py§
\end{lstlisting}

Git commit at this point will apply the staged code to the commit, and leave the file in the modified state with the remaning, unstage lines.
We have already covered commits, so let's stay in this state to explore the \textbf{diff} command.

\marginnote{\texttt{git diff} will display the full diff between the modified content and HEAD. Already staged data does not appear.}
\begin{lstlisting}[style=BashInputStyle]
  $ git diff
  diff --git a/python/calc.py b/python/calc.py
  index b66135e..9178e52 100644
  --- a/python/calc.py
  +++ b/python/calc.py
  @@ -17,6 +17,7 @@ def mul(op1, op2):
   def div(op1, op2):
     return op1 / op2
 
  `+ New comment, I will not stage it for now`
   def pow(op1, op2):
     return op1 ** op2
 \end{lstlisting}
\marginnote{\texttt{git diff} with the \textbf{cached} option is the opposite: it displays the diff between the staged content and HEAD, and ignores modified content.}
 \begin{lstlisting}[style=BashInputStyle]
  $ git diff --cached
  diff --git a/python/calc.py b/python/calc.py
  index c27b82f..b66135e 100644
  --- a/python/calc.py
  +++ b/python/calc.py
  @@ -2,6 +2,7 @@ import os
   import sys
   import argparse
 
  `+ New comment. I will stage this first`
   choices_cmd = ['add', 'sub', 'mul', 'div', 'pow', 'mod', 'floor']
 
   def add(op1, op2):
\end{lstlisting}

\subsection{Stage all modified and untracked in 1 command}

I recommend avoiding this as much as possible, but for the record, it is possible to use a single command to add all untracked and modified files to the staging area:

\begin{lstlisting}[style=BashInputStyle]
  $ git add -A
\end{lstlisting}

\subsection{Commit all modified files in 1 command}

Another shortcut worth knowing but which should be avoided in most cases is the commit option to stage all outstanding modifications and record a new commit:
\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitcommit-am-schema.pdf}
  \label{fig:gitcommit-am}
  \caption{Git commit -am stages all modified files and applies a commit immediately after.}
\end{marginfigure}
\begin{lstlisting}[style=BashInputStyle]
  $ git commit -am "One big commit"
\end{lstlisting}

I prefer avoiding this because commits should be decoupled by features and it is rare that there are no superfluous modifications when developing a feature.
This \texttt{-a} option doesn't leave time to verify the contents of the commit before applying changes, whereas decoupling staging and commit phases allows to view the staged changes with commands like:

\begin{lstlisting}[style=BashInputStyle]
  $ git diff --cached
\end{lstlisting}

\subsection{Unstaging stuff}

To unstage work, \texttt{git reset} comes in handy.
This command is very multi-purpose in Git, for now we will use its default behavior which is to unstage modifications without deleting them.
\texttt{git reset} without arguments will unstage all currently staged changes, and bring them back to their former state (modified or untracked).

\marginnote{Although it's technically possible to combine \texttt{[tree-ish]} and \texttt{[file]} options to git reset, this will not actually delete the commit if there are other non-reset changes in the commits. Thus the content is reset as desired, but applied this reset requires to stage and commit the modifications in new commits. Git revert has a similar behavior in the sense that we are adding commits to actually undo work.}

\begin{lstlisting}[style=BashInputStyle]
  $ git reset 
\end{lstlisting}

This is only a partial explanation of why git reset does this.
Like many git commands which accept a \textbf{tree-ish} as optional argument, git reset assumes \texttt{HEAD} when unspecified.
The general \texttt{git reset} actually undoes commits from the current state up until (and not including) the commit referenced by the tree-ish.

\begin{lstlisting}[style=BashInputStyle]
  $ git reset [tree-ish]
\end{lstlisting}

Finally, unstaging can also be applied on a per-file basis.

\begin{lstlisting}[style=BashInputStyle]
  $ git reset [file]
\end{lstlisting}

\section{Untracking and Deleting files}

Deleting a file is treated in the same way as other modifications in Git.
The cleanest way to remove a file from disk as well as from the Git repository is to use \texttt{git rm} on it:

\begin{lstlisting}[style=BashInputStyle]
  $ git rm <file>
\end{lstlisting}

This performs two things: it deletes the file from disk, and \textbf{stages} the removal of this file.
The next commit will thus include the deletion of the file.

If you want to untrack a file from Git without deleting it locally, use the \texttt{cached} option:

\begin{lstlisting}[style=BashInputStyle]
  $ git rm --cached <file>
\end{lstlisting}

Git will stage the file to be removed in the next commit, but will not touch the file locally.

\pagebreak

\section{Pushing work to a remote}

We have progressed locally on the master branch.
So far, all our modifications are local and we have not shared our work with anyone.

\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitcommit-pre-push.png}
  \label{fig:gitcommit-pre-push}
  \caption{Local and remote repo status before the push. Local master is 4 commits ahead of origin's.}
\end{marginfigure}
\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitpush-schema.pdf}
  \label{fig:gitpush-schema}
\end{marginfigure}
\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitcommit-post-push.png}
  \label{fig:gitcommit-post-push}
  \caption{After pushing master to origin, both branches are at the same point in history.}
\end{marginfigure}

The \texttt{git push} command is used to push individual branches from the local repository to a remote one.
The command produces the following output.

\begin{lstlisting}[style=BashInputStyle]
  $ git push origin master 
  Counting objects: 17, done.
  Delta compression using up to 8 threads.
  Compressing objects: 100% (10/10), done.
  Writing objects: 100% (14/14), 1.29 KiB, done.
  Total 14 (delta 4), reused 0 (delta 0)
  To git@gitlab.server.com:login/lesson1
     71aaf45..37b9258  master -> master
\end{lstlisting}

Git push is only possible if the remote branch to which we are pushing has not been updated in the meantime.
In other words, it succeeds \textit{if the remote branch is in the direct history of the local branch}.

If pushing is not possible because the remote branch has been updated (usually, by someone else), we enter a multi-user workflow which we will cover later.
\marginnote{I use integrate here to stay general. There are many ways to do this, like merge, rebase, hard reset...}
In a few words, the remote modifications must first be \textbf{fetched} locally and "integrated" in our work before we can contribute.

\section{Applying our changes to a feature branch first}

So far we have worked on a master branch.
We will conclude this first session by working in feature branches, and merging them into the master branch once they are stable.

\subsection{Branching: very lightweight}

Branching in Git is as simple as adding a new label to an existing commit.
\marginnote{This is very different from some other SCMs, where creating a branch is a lengthy process involving copying the entire working tree.}
The working tree is left entirely intact when a branch is created.
\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitbranch-feature.png}
  \label{fig:gitbranch-feature}
  \caption{A new branch is just a new label.}
\end{marginfigure}
\begin{lstlisting}[style=BashInputStyle]
  $ git branch -a
  * `master`
    §remotes/origin/HEAD -> origin/master§
    §remotes/origin/master§

    $ git branch feature

  $ git branch -a
    feature
  * `master`
    §remotes/origin/HEAD -> origin/master§
    §remotes/origin/master§
\end{lstlisting}

We have a new local branch called feature branch, currently pointing to the same commit as master.
We are not quite ready to start applying changes, because \texttt{git branch} and \texttt{git status} tell us that we are still in master.
To progress in the \texttt{feature} branch rather then \texttt{master} we must use \textbf{checkout}:

\begin{lstlisting}[style=BashInputStyle]
  $ git checkout feature
  $ git branch -a
  * feature
    master
    remotes/origin/HEAD -> origin/master
    remotes/origin/master
\end{lstlisting}

\subsection{Integrating a feature branch back into master}

Now, we can start adding commits to the feature branch just like we have done for master.
Once we are satisfied with our work, we can merge it back into master.
We will not go into too much details for now, but the general idea is:

\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitmerge-ff.pdf}
  \label{fig:gitmerge-ff}
  \caption{Merging in fast-forward mode.}
\end{marginfigure}

\begin{lstlisting}[style=BashInputStyle]
  $ git checkout master
  $ git merge feature
\end{lstlisting}

If master has not progressed since we branched off with feature, the master branch will be \textbf{fast-forwarded} to the feature branch.
If a branching history is preferred, we can force it with \texttt{no-ff}:

\begin{marginfigure}%
  \centering
  \includegraphics[width=\linewidth]{gitmerge-noff.pdf}
  \label{fig:gitmerge-noff}
  \caption{Merging in no-fast-forward mode creates an explicit merge commit.}
\end{marginfigure}

\begin{lstlisting}[style=BashInputStyle]
  $ git checkout master
  $ git merge feature --no-ff
\end{lstlisting}

This creates an additional commit, called a merge commit, with 2 parents: the last commit on each branch prior to the merge.
If master \textit{did} progress since we branched off with the feature branch, the merge operation will automatically result in an extra merge commit.

In the next session, we will dig further into workflows dealing with multiple branches, multiple people, and learn other ways to integrate changes such as \textbf{rebase}.

\bibliography{tufte-latex/sample-handout}
\bibliographystyle{plainnat}



\end{document}
